<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>StudySphere</title>
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/css/bootstrap.min.css" rel="stylesheet">
	<style>
		/* Auth overlay to block page for unauthenticated users */
		#authOverlay {
			position: fixed;
			inset: 0;
			background: rgba(0,0,0,0.45);
			backdrop-filter: blur(5px);
			-webkit-backdrop-filter: blur(5px);
			z-index: 10800;
			display: none;
			align-items: center;
			justify-content: center;
		}
		#authOverlay .auth-card {
			background: #101010;
			color: #fff;
			padding: 1.25rem;
			border-radius: .6rem;
			box-shadow: 0 12px 30px rgba(0,0,0,0.6);
			max-width: 420px;
			text-align: center;
		}
		#authOverlay .auth-card .btn { margin: .25rem; }
		/* When auth overlay is active, slightly dim/blur the underlying content */
		.blurred-body > *:not(#authOverlay) {
			filter: blur(4px) grayscale(.05) brightness(.9);
			pointer-events: none;
		}
	</style>
</head>
<body class="d-flex flex-column min-vh-100" data-bs-theme="dark">
  	<header class="p-3 sticky-top bg-dark shadow-sm">
		<div class="container">
			<div class="d-flex flex-wrap align-items-center justify-content-center justify-content-lg-start">
				<a href="/" class="d-flex align-items-center mb-2 mb-lg-0 text-white text-decoration-none">
					<svg class="bi me-2" width="40" height="32" role="img" aria-label="Logo"></svg>
				</a>
				<ul class="nav nav-pills col-12 col-lg-auto me-lg-auto mb-2 justify-content-center mb-md-0">
					<li><a href="/" class="nav-link px-3 text-white">Home</a></li>
					<li><a href="/leaderboard.html" class="nav-link px-3 text-white">Leaderboard</a></li>
					<li><a href="/practice.html" class="nav-link px-3 text-white">Practice</a></li>
					<li><a href="/rank.html" class="nav-link px-3 text-warning">Rank</a></li>
					<li><a href="/about.html" class="nav-link px-3 text-white">About</a></li>
				</ul>
				<div class="text-end">
					<a href="/login.html" type="button" class="btn btn-outline-light me-2">Login</a>
					<a href="/signup.html" type="button" class="btn btn-warning">Sign-up</a>
				</div>
			</div>
		</div>

	<!-- recording preview moved into matchArea so it appears beside the timer -->
    </header>

	<!-- Auth overlay for unauthenticated users -->
	<div id="authOverlay" role="dialog" aria-modal="true">
		<div class="auth-card">
			<h5 class="text-warning mb-2">Please sign in</h5>
			<p class="mb-3 small text-muted">You need to be logged in to start rank and earn XP.</p>
			<div>
				<a href="/login.html" class="btn btn-outline-light">Log in</a>
				<a href="/signup.html" class="btn btn-warning">Sign up</a>
			</div>
		</div>
	</div>

	<div class="container py-4">
		<!-- <div class="alert alert-warning text-center my-4" role="alert">
			<strong>Rank Challenge</strong> — Compete against a bot to earn bonus XP.
		</div> -->

		<!-- Inline match area: circular timer + stop button (replaces modal) -->
		<div id="matchArea" class="d-flex flex-column align-items-center" style="display:none; gap:1rem;">
			<div class="d-flex align-items-start" style="gap:2rem;">
				<div id="circle-match" style="width:320px;height:320px;position:relative;">
					<svg id="matchSvg" width="320" height="320" viewBox="0 0 260 260" style="transform:rotate(-90deg);">
						<circle cx="130" cy="130" r="110" stroke="#222" stroke-width="18" fill="none" />
						<circle id="matchCircle" cx="130" cy="130" r="110" stroke="#ffc107" stroke-width="14" fill="none" stroke-linecap="round" stroke-dasharray="690" stroke-dashoffset="690" />
					</svg>
					<div id="matchTimer" style="position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font-size:2.5rem;font-weight:700;color:#ffc107;">00:00</div>
				</div>
				<!-- Recording preview shown to the right of the timer -->
				<div id="recordPreview" style="display:none;flex-direction:column;align-items:center;gap:0.6rem;">
					<div id="recordBlack" style="width:220px;height:150px;border-radius:1.2em;background:#111;box-shadow:0 0 16px 2px #222;display:flex;align-items:center;justify-content:center;"></div>
					<video id="recordVideo" width="220" height="150" style="border-radius:1.2em;object-fit:cover;background:#111;box-shadow:0 0 16px 2px #dc3545;display:none;" autoplay muted playsinline></video>
					<span id="recordStatus" style="display:none;align-items:center;gap:0.7em;">
						<span id="recordDot" style="display:inline-block;width:12px;height:12px;border-radius:50%;background:#dc3545;box-shadow:0 0 12px 3px #dc3545;animation:record-blink 1s infinite alternate;"></span>
						<span class="fw-semibold text-danger">Tracking</span>
					</span>
				</div>
			</div>
			<div class="d-flex flex-column align-items-center" style="gap:.75rem;">
				<div id="matchStatus" class="text-muted">Start a match now!</div>
				<div class="d-inline-flex align-items-center gap-2">
					<button id="findOpponentBtn" class="btn btn-warning fw-semibold">Start</button>
				</div>
			</div>
		</div>
	</div>
  
	<div class="container"> 
		<footer class="py-3 my-4"> 
		<ul class="nav justify-content-center border-bottom pb-3 mb-3"> 
			<li class="nav-item"><a href="/" class="nav-link px-2 text-body-secondary">Home</a></li> 
			<li class="nav-item"><a href="/leaderboard.html" class="nav-link px-2 text-body-secondary">Leaderboard</a></li> 
			<li class="nav-item"><a href="/practice.html" class="nav-link px-2 text-body-secondary">Practice</a></li> 
			<li class="nav-item"><a href="/rank.html" class="nav-link px-2 text-body-secondary">Rank</a></li> 
			<li class="nav-item"><a href="/about.html" class="nav-link px-2 text-body-secondary">About</a></li> 
		</ul> 
		<p class="text-center text-body-secondary">© 2025 StudySphere</p> 
		</footer> 
	</div>

	<script>
		// --- Auth overlay helpers ---
		function showAuthOverlay() {
			const overlay = document.getElementById('authOverlay');
			if (!overlay) return;
			overlay.style.display = 'flex';
			document.body.classList.add('blurred-body');
			// disable pointer events for underlying content
			document.body.style.pointerEvents = 'none';
			overlay.style.pointerEvents = 'auto';
		}
		function hideAuthOverlay() {
			const overlay = document.getElementById('authOverlay');
			if (!overlay) return;
			overlay.style.display = 'none';
			document.body.classList.remove('blurred-body');
			document.body.style.pointerEvents = '';
		}
		async function ensureAuthOrPrompt() {
			// If a user is signed in, hide overlay; otherwise show it.
			const user = await getUser();
			if (user) {
				hideAuthOverlay();
				return true;
			} else {
				showAuthOverlay();
				return false;
			}
		}
	</script>
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/js/bootstrap.bundle.min.js"></script>
	<!-- Supabase JS CDN -->
	<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js"></script>
	<script>
		// Replace with your Supabase project URL and anon key
		const SUPABASE_URL = 'https://mtrdbguzixngcvzcxwlz.supabase.co';
		const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im10cmRiZ3V6aXhuZ2N2emN4d2x6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTcxMzY1NTIsImV4cCI6MjA3MjcxMjU1Mn0.Bcedj4oZbqY0sWzTXULtPeiPlNDdy2RnVef_u68tHVU';
		const sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

		// Helper: get user from localStorage/session
		async function getUser() {
			// Try to get from localStorage (persisted session)
			let user = null;
			try {
				const session = JSON.parse(localStorage.getItem('sb-session'));
				if (session && session.user) user = session.user;
			} catch {}
			// If not found, try Supabase
			if (!user) {
				const { data } = await sb.auth.getUser();
				user = data && data.user;
			}
			return user;
		}

		// On login/signup, save session to localStorage
		sb.auth.onAuthStateChange((event, session) => {
			if (session) {
				localStorage.setItem('sb-session', JSON.stringify(session));
			} else {
				localStorage.removeItem('sb-session');
			}
			updateUserUI();
			// Ensure overlay state matches auth
			ensureAuthOrPrompt();
		});

		// Fetch XP from Supabase 'profiles' table
		async function getUserXP(userId) {
			if (!userId) return null;
			// Assumes a 'profiles' table with 'id' (uuid, matches user.id) and 'xp' (integer)
			const { data, error } = await sb.from('profiles').select('xp').eq('id', userId).single();
			if (error) return null;
			return data?.xp ?? 0;
		}

		// Update UI: replace login/signup with user info if logged in
		async function updateUserUI() {
			const user = await getUser();
			const userDiv = document.querySelector('.text-end');
			if (!userDiv) return;
			if (user) {
				// Get name and avatar (fallback to email/initial)
				const name = user.user_metadata?.name || user.email || 'User';
				const avatar = user.user_metadata?.avatar_url || `https://ui-avatars.com/api/?name=${encodeURIComponent(name)}&background=ffc107&color=222&bold=true`;
				// Fetch XP from Supabase
				let xp = await getUserXP(user.id);
				if (xp === null) xp = 0;
				userDiv.innerHTML = `
					<span class="badge rounded-pill bg-warning text-dark me-3 align-middle" style="font-size:1rem;vertical-align:middle;">${xp} XP</span>
					<div class="dropdown d-inline-block align-middle">
						<a href="#" class="d-flex align-items-center text-white text-decoration-none dropdown-toggle" id="userDropdown" data-bs-toggle="dropdown" aria-expanded="false">
							<img src="${avatar}" alt="avatar" width="32" height="32" class="rounded-circle me-2 border border-warning">
							<span class="fw-semibold">${name}</span>
						</a>
						<ul class="dropdown-menu dropdown-menu-end dropdown-menu-dark" aria-labelledby="userDropdown">
							<li><a class="dropdown-item" href="/profile.html">Profile</a></li>
							<li><hr class="dropdown-divider"></li>
							<li><a class="dropdown-item" href="#" id="logoutBtn">Log out</a></li>
						</ul>
					</div>
				`;
				// Add logout handler
				setTimeout(() => {
					const logoutBtn = document.getElementById('logoutBtn');
					if (logoutBtn) {
						logoutBtn.onclick = async function(e) {
							e.preventDefault();
							await sb.auth.signOut();
							localStorage.removeItem('sb-session');
							window.location.reload();
						};
					}
				}, 0);
			} else {
				// Not logged in: show login/signup
				userDiv.innerHTML = `
					<a href="/login.html" type="button" class="btn btn-outline-light me-2">Login</a>
					<a href="/signup.html" type="button" class="btn btn-warning">Sign-up</a>
				`;
			}
		}

		// On page load
		updateUserUI();
		ensureAuthOrPrompt();

		// --- Rank page logic ---
	const findBtn = document.getElementById('findOpponentBtn');
	const matchAreaEl = document.getElementById('matchArea');
	const matchTimerEl = document.getElementById('matchTimer');
	const matchStatusEl = document.getElementById('matchStatus');

		let matchInterval = null;
		let matchElapsed = 0;
		let botStopAt = null; // seconds
		let inMatch = false;
		// fast looping circle progress (independent of bot time)
		let progressAnimId = null;
		const PROGRESS_CYCLE_MS = 2500; // one full circle every 2.5s

		function startCircleProgressLoop() {
			const circle = document.getElementById('matchCircle');
			if (!circle) return;
			const r = parseFloat(circle.getAttribute('r')) || 110;
			const dash = 2 * Math.PI * r;
			circle.setAttribute('stroke-dasharray', dash);
			let startTs = null;
			function step(ts) {
				if (!startTs) startTs = ts;
				const elapsedMs = ts - startTs;
				const cycleMs = PROGRESS_CYCLE_MS;
				const phase = (elapsedMs % cycleMs) / cycleMs; // 0..1 looping
				const offset = Math.max(0, dash - dash * phase);
				circle.setAttribute('stroke-dashoffset', offset);
				progressAnimId = requestAnimationFrame(step);
			}
			progressAnimId = requestAnimationFrame(step);
		}

		function stopCircleProgressLoop() {
			if (progressAnimId) {
				cancelAnimationFrame(progressAnimId);
				progressAnimId = null;
			}
		}

		// Reuse RPC helper pattern from practice page
		async function addXpViaRpc(minutes, flat = false) {
			const mins = Math.max(1, Math.min(360, Number(minutes) || 0)); // clamp to [1,360]
			try {
				const { data, error } = await sb.rpc('award_xp', { p_minutes: mins, p_flat: flat });
				if (error) throw error;
				return Array.isArray(data) ? data[0] : data;
			} catch (err) {
				console.error('award_xp RPC error:', err);
				throw err;
			}
		}

		function formatTimeSimple(secs) {
			const m = Math.floor(secs / 60).toString().padStart(2, '0');
			const s = (secs % 60).toString().padStart(2, '0');
			return `${m}:${s}`;
		}

		function showMatchArea() {
			if (!matchAreaEl) return;
			matchAreaEl.style.display = 'flex';
			// switch find button into Stop mode
			if (findBtn) {
				findBtn.textContent = 'Stop';
				findBtn.classList.remove('btn-warning');
				findBtn.classList.add('btn-danger');
				findBtn.disabled = false;
			}
			// show recording preview and enlarge it to match practice UX
			const preview = document.getElementById('recordPreview');
			const black = document.getElementById('recordBlack');
			const video = document.getElementById('recordVideo');
			if (preview) preview.style.display = 'flex';
			if (black) {
				black.style.width = '420px';
				black.style.height = '315px';
				black.style.borderRadius = '1.5em';
			}
			if (video) {
				video.style.width = '420px';
				video.style.height = '315px';
			}
		}
		function hideMatchArea() {
			if (!matchAreaEl) return;
			matchAreaEl.style.display = 'none';
			// restore find button to initial state
			if (findBtn) {
				findBtn.style.display = 'inline-block';
				findBtn.textContent = 'Find a Player';
				findBtn.classList.remove('btn-danger');
				findBtn.classList.add('btn-warning');
				findBtn.disabled = false;
			}
			// hide recording preview and restore small sizes
			const preview = document.getElementById('recordPreview');
			const black = document.getElementById('recordBlack');
			const video = document.getElementById('recordVideo');
			if (preview) preview.style.display = 'none';
			if (black) {
				black.style.width = '220px';
				black.style.height = '150px';
				black.style.borderRadius = '1.2em';
			}
			if (video) {
				video.style.width = '220px';
				video.style.height = '150px';
			}
		}

		// --- Recording helpers (same pattern as practice page) ---
		let recordStream = null;
		async function startRecordingPreview() {
			const black = document.getElementById('recordBlack');
			const video = document.getElementById('recordVideo');
			const status = document.getElementById('recordStatus');
			if (black) black.style.display = 'none';
			if (video) video.style.display = 'block';
			if (status) status.style.display = 'flex';
			try {
				if (!recordStream) {
					recordStream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 }, audio: false });
				}
				if (video) video.srcObject = recordStream;
			} catch (err) {
				if (black) black.style.display = 'flex';
				if (video) video.style.display = 'none';
				if (status) status.style.display = 'none';
				console.warn('Camera unavailable:', err);
			}
		}
		function stopRecordingPreview() {
			const black = document.getElementById('recordBlack');
			const video = document.getElementById('recordVideo');
			const status = document.getElementById('recordStatus');
			if (black) black.style.display = 'flex';
			if (video) video.style.display = 'none';
			if (status) status.style.display = 'none';
			if (recordStream) {
				const tracks = recordStream.getTracks();
				tracks.forEach(t => t.stop());
				recordStream = null;
				if (video) video.srcObject = null;
			}
		}

		findBtn.addEventListener('click', async function() {
			// If already in a match, this button acts as Stop
			if (inMatch) {
				findBtn.disabled = true;
				findBtn.textContent = 'Stopping...';
				// user stopped before bot -> lose
				endMatch(false, null);
				return;
			}
			// Simulate matchmaking delay
			findBtn.disabled = true;
			findBtn.textContent = 'Searching...';
			await new Promise(r => setTimeout(r, 1000 + Math.random() * 1500));
			findBtn.textContent = 'Player Found!';
			setTimeout(() => findBtn.textContent = 'Start Match', 700);
			// Start match
			setTimeout(() => {
				startMatch();
				findBtn.disabled = false;
				// after starting, show Stop label
				if (findBtn) {
					findBtn.textContent = 'Stop';
					findBtn.classList.remove('btn-warning');
					findBtn.classList.add('btn-danger');
				}
			}, 900);
		});

		function startMatch() {
			if (inMatch) return;
			inMatch = true;
			matchElapsed = 0;
			// Bot chooses a random stop between 15 and 60 minutes
			const botMinutes = 15 + Math.floor(Math.random() * 46); // 15..60
			botStopAt = botMinutes * 60;
			matchStatusEl.textContent = `Match started. Good luck!`;
			showMatchArea();
			// start local timer
			matchTimerEl.textContent = formatTimeSimple(matchElapsed);
			matchInterval = setInterval(() => {
				matchElapsed++;
				matchTimerEl.textContent = formatTimeSimple(matchElapsed);
				// Bot stops when reaches its time
				if (matchElapsed >= botStopAt) {
					// bot stopped first -> user wins
					endMatch(true, null);
				}
			}, 1000);
			// start recording preview
			startRecordingPreview();
			// start fast looping circle progress independent of bot timer
			startCircleProgressLoop();
		}

		async function endMatch(userStillReading, modalInstance) {
			// userStillReading: true if user outlasted bot (user wins)
			if (matchInterval) {
				clearInterval(matchInterval);
				matchInterval = null;
			}
			inMatch = false;
			// stop recording preview when match ends
			stopRecordingPreview();
			// stop fast looping circle animation
			stopCircleProgressLoop();
			// compute minutes passed (round to nearest minute)
			const mins = Math.round(matchElapsed / 60);
			if (mins <= 0) {
				// nothing awarded
				matchStatusEl.textContent = 'No XP awarded (less than 1 minute).';
			} else {
				try {
					if (userStillReading) {
						// user wins: award minutes^2 (server-side)
						const { data, error } = await sb.rpc('award_xp', { p_minutes: mins, p_mode: 'square' });
						if (error) throw error;
						const awarded = Array.isArray(data) ? data[0] : data;
						matchStatusEl.textContent = `You won! Awarded ${awarded ?? 0} XP.`;
					} else {
						// user lost: flat minutes (server-side flat)
						const { data, error } = await sb.rpc('award_xp', { p_minutes: mins, p_mode: 'flat' });
						if (error) throw error;
						const awarded = Array.isArray(data) ? data[0] : data;
						matchStatusEl.textContent = `You lost. Awarded ${awarded ?? 0} XP.`;
					}
					if (typeof updateUserUI === 'function') updateUserUI();
				} catch (err) {
					console.error('Failed to award XP:', err);
					matchStatusEl.textContent = 'Network error: XP not awarded.';
				}
			}
			// disable action button briefly and hide match area after short delay
			if (findBtn) findBtn.disabled = true;
			setTimeout(() => {
				hideMatchArea();
				if (findBtn) {
					findBtn.disabled = false;
					findBtn.textContent = 'Start';
					findBtn.classList.remove('btn-danger');
					findBtn.classList.add('btn-warning');
				}
				// reset circle
				const circle = document.getElementById('matchCircle');
				if (circle) {
					const r = parseFloat(circle.getAttribute('r')) || 110;
					const dash = 2 * Math.PI * r;
					circle.setAttribute('stroke-dasharray', dash);
					circle.setAttribute('stroke-dashoffset', dash);
				}
			}, 2000);
		}

		// Stop the match when the tab/window loses focus (treat as user stop)
		document.addEventListener('visibilitychange', () => {
			if (document.hidden && inMatch) {
				endMatch(false, null);
			}
		});
		window.addEventListener('blur', () => {
			if (inMatch) {
				endMatch(false, null);
			}
		});

	</script>
</body>
</html>
